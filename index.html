<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux/x86 version 5.3.9">
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC Next Version Use Cases</title>
  <script class="remove" src="respec-w3c-common.js" type="text/javascript"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document describes a set of use cases motivating the development of
    WebRTC Next Version (WebRTC-NV), as well as the requirements derived from
    those use cases.</p>
  </section>
  <section id="sotd">
  </section>
  <section id="overview*">
    <h2>Scope and Motivation</h2>
    <p>To motivate the development of WebRTC 1.0, the IETF RTCWEB WG developed [[RFC7478]].
    This document describes use cases motivating the development of
    "WebRTC Next Version" (WebRTC-NV), and the requirements deriving from those use cases.
    The use cases fall into one of two categories:
    enhancements to use cases already covered in [[RFC7478]], and
    new use cases which are not supported in WebRTC 1.0 [[WEBRTC]] without extensions.</p>
    <section id="conformance">
    </section>
  </section>
  <section id="existingusecases*">
    <h2>Existing Use Cases</h2>
      <p>The uses cases in this section improve upon use cases described in [[RFC7478]].</p>
    <section id="multipartygame*">
      <h3>Multiparty online game with voice communications</h3>
      <p>[[RFC7478]] Section 2.3.12 describes a use case involving a multiparty online game
        with voice communications. In these scenarios, reducing time to join the game and
        receive media is important. To minimize this, ICE enhancements are desirable, such as
        the ability to control candidate gathering and pruning.  Also, allowing a participant
        to broadcast a configuration to a “room” abstraction (maintained on a server), with
        other room participants responding back directly, avoiding a separate discovery step,
        minimizes conference establishment time. Also, managing audio quality and latency in
        a fair manner between multiple connections prevents queue buildup. Supporting this
        enhancement adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N01             The user agent can control candidate gathering
                   and pruning, limiting the networks on which
                   candidates are gathered, the types of candidates,
                   etc.
   N02             The user agent must be capable of establishing multiple
                   connections to peers without generating a separate
                   configuration ("offer") for each connection prior to
                   establishment.
   N03             Congestion control must be able to manage audio
                   quality and latency in a fair manner between multiple
                   connections.
</pre>
<p>Experience: This use case has been implemented by a gaming service utilizing [[ORTC]].</p>

References:
<ol>
  <li><a href="https://github.com/w3c/ortc/issues/54">ORTC Issue 54</a></li>
  <li><a href="https://github.com/w3c/ortc/issues/603">ORTC Issue 603</a></li>
</ol>
    </section>
    <section id="mobility*">
      <h3>Mobility</h3>
      <p>[[RFC7478]] Section 2.3.6 describes a simple communications service where the user changes access network
      during the session. This use case is enhanced by being able to re-route media over an alternate path
      (potentially taking network cost into account) without need for signaling.</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N04             The ICE agent must be able to maintain multiple
                   candidate pairs and move traffic between them.
   N05             The ICE agent must be able to take the network
                   cost into account when considering re-routing.
</pre>
References:
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list proposal</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0019.html">Mailing list proposal</a></li>
  <li><a href="https://github.com/w3c/ortc/issues/583">ORTC Issue 583</a></li>
</ol>
    </section>
    <section id="videoconferencing*">
      <h3>Video Conferencing with a Central Server</h3>
      <p>[[RFC7478]] Section 2.4.3.1 describes a use case involving Multiparty Video Communications with
      a central conferencing server. In such a use case, clients with disparate capabilities such as
      differing bandwidth availability,
      screen size and maximum displayable frame rate may participate in the same conference.
      In such a situation it is advantageous to support Scalable Video Coding (SVC).
      Encoding with temporal scalability is supported by several browsers today and is utilized by most
      centralized conferencing services.</p>
      <p>It is expected that spatial scalability (supported by VP9 and AV1) will become more popular with time.
      In this use case, if the desired video codec is known beforehand and participants are muted by default
      (as in a very large meeting), it is desirable to allow new participants to start receiving immediately,
      without negotiation. Supporting this enhancement adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N06             The user agent must be able to encode and decode
                   video utilizing temporal scalability and (if
                   supported by the chosen codec) spatial scalability.
   N07             A user agent can receive audio/video without requiring
                   construction of a corresponding sender object.
   N08             It is possible to select the sending and/or
                   receiving codec without negotiation.
   N09             The user agent must be able to control
                   robustness (RTX, RED, FEC) applied to individual 
                   simulcast and SVC layers.
</pre>
<p>This use case has been implemented by conferencing services utilizing [[ORTC]],
as well as proprietary additions to [[WEBRTC]].</p>
    </section>
</section>
<section id="newusecases*">
    <h2>New Use Cases</h2>
<p>Several new uses cases relate to scenarios that cannot be supported in [[WEBRTC]] without extensions.</p>
    <section id="filesharing*">
    <h3>File Sharing</h3>
    <p>Participants in a mesh exchange large files without disruption to audio/video sessions.
It is also possible for a participant to send a large file to a user who is not currently online.
Supporting this use case adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N10             It must be possible for the user agent to initiate
                   transfer of a large file with a single API operation.
   N11             The application must be able to signal backpressure
                   (flow control) when receiving data. It must also
                   receive a backpressure signal when sending data.
   N12             It must be possible for the user agent to transfer
                   data utilizing a congestion control algorithm
                   that does not compete aggressively with
                   audio/video communications.
   N13             It must be possible to support data exchange
                   in a worker.
</pre>
References:
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list discussion</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0082.html">Mailing list discussion</a></li>
</ol>
    </section>
    <section id="iot*">
<h3>Internet of Things</h3>
<p>An IoT sensor maintains a  long-term connection and seeks to minimize power consumption.
Some of the sensor’s data may need to be sent reliable and ordered while other sensors may
provide data that can be sent unreliable and unordered or in a partially reliable manner.
This use case adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N14            The application must be able to minimize ICE
                  connectivity checks.
   N15            The application must be able to control aspects
                  of the data transport  (e.g. set the SCTP
                  heartbeat interval or turn it off), RTO values,
                  etc.
   N16            It must be possible to send arbitrary data
                  reliable, unreliable or partially reliable with
                  a specific maximum number of retransmissions
                  or a specific maximum timeout.
   N17            It must be possible to send arbitrary data
                  ordered or unordered.
</pre>
Reference:
<a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0079.html">Mailing list discussion</a>
    </section>
    <section id="funnyhats*">
<h3>Funny Hats</h3>
<p>A communications service that manipulates captured media prior to encoding and after
decoding to provide effects including:</p>
<ol>
  <li>Funny hats</li>
  <li>Background removal or blurring</li>
  <li>In-browser compositing</li>
  <li>Voice effects</li>
  <li>Stress detection</li>
</ol>
<p>This use case requires manipulation of raw media from both local and remote sources. Since
media processing can be CPU intensive, enabling it to occur off the main thread is important,
as is enabling the processing to take advantage of the GPU. This use case adds the following
requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N18             The application must be able to obtain raw media
                   from the capture device in desired formats.
   N19             The application must be able to insert processed
                   frames into the outgoing media path.
   N20             The application must be able to obtain decoded
                   media from the remote party.
   N21             It must be possible to efficiently share media
                   between the main thread and worker threads.
   N22             It must be possible to do efficient media
                   manipulation in worker threads by utilizing the GPU.
</pre>

References:
<ol>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0037.html">Mailing list discussion</a></li>
  <li><a href="https://lists.w3.org/Archives/Public/public-webrtc/2018Jun/0006.html">Mailing list discussion</a></li>
  <li><a href="https://ai.googleblog.com/2016/11/enhance-raisr-sharp-images-with-machine.html">Sharper Image Research</a></li>
</ol>
    </section>
    <section id="machinelearning*">
<h3>Machine Learning</h3>
<p>In a web game called “NameTheBird.com” participants use their devices to provide audio and video observations of
birds to the service along with identifications for training purposes, allowing the service to identify birds from
the provided audio and video and returning this information to the users in real-time.</p>
<p>The web application has a site specific federated learning-based classifier for contextual object detection,
user intent prediction and media manipulation, allowing it to augment the streams it receives and inject identifying
or other supplemental information into the streams sent or received.</p>
<p>The shared classification models are trained on the birds found by the participants and are based on the feedback
of the participants. Each device client updates of the model are up-streamed to a shared model server that pushes
updates of the global model to the clients.</p>
<p>Implementation outline:</p>
<ol>
  <li>Originating media (raw) streams are cloned for inference and training purposes, denoted “inference stream” and
  “training stream”, with the inference stream also being the media stream shared with peer(s). The cloning can occur
  any time during a session.</li>
  <li>Inference stream: A web site specific classifier acts on the raw inference stream, with the result used to
  guide a custom encoder in the sender device and send metadata to the server and peer devices outside the media stream.
  The encoder adds proper augmentation, e.g. sign with “name this bird” hovering over the enlarged bird in case of video
  enrichment, or enhanced bird song if audio.</li>
  <li>Training stream: Model in training classifies the raw data and evaluate the classification using user feedback,
  said feedback loop being web site specific. The evaluation may be  “online” or “offline”, offline meaning the training
  is done at a later stage on the recorded encoded media set.</li>
  <li>Both inference stream and training streams may use payload protection depending on trust model on compute
  resources for optional intermedia server side of app.</li>
  <li>Both inference stream and training streams use transport object for communicating with peers or servers,
  the communication in some cases can be a site specific QUIC based transport solution, in others RTP based.</li>
</ol>
<p>This use case adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N18             The application must be able to obtain raw media
                   from the capture device.
   N19             The application must be able to insert processed
                   frames into the outgoing media path.
   N20             The application must be able to obtain decoded
                   media from the remote party.
   N21             It must be possible to efficiently share media
                   between the main thread and worker threads.
   N22             It must be possible to do efficient media
                   manipulation in worker threads.
</pre>
    </section>
    <section id="vr*">
<h3>Virtual Reality Gaming</h3>
<p>A virtual reality gaming service utilizing a centralized conferencing server wants
to synchronize data with media, using an existing Selective Forwarding Unit (SFU)
to distribute the data. This use case adds the following requirements:</p>
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   N23             The user agent must be able to send data synchronized
                   with audio and video.
</pre>

References:
<a href="https://lists.w3.org/Archives/Public/public-webrtc/2018May/0063.html">Mailing list discussion</a>
    </section>
    <section id="no-trust-webex">
<h3>Don't Pown My Video Conferencing </h3>
<p>
  Cloud video conferencing systems have no need to be able to access
  the cleartext media and text flowing through their servers.
  Some of these conferencing services desire to be able to promote trust
  by explicitly showing they do not have access to contents of their
  users' calls. They are trusted to connect the right people to the
  conference and to route the packets but they are not trusted to access
  the audio and video media or text in the call.
</p>
<p>Solutions to this problem fall into two major categories: one where
  the JavaScript comes from a source trusted to see the media contents,
  and one where it does not.
</p>
         <section id="untrusted*">
<h4>Untrusted JavaScript Cloud Conferencing</h4>
<p>
  There are many cases where a system such as WebEx is trusted to
  connect the members of a conference but has no need to access the
  contents of the conference. This is true of the majority of
  conferencing systems on the web today.  Just to highlight the
  scope of this requirement, there are more minutes of WebRTC
  that are used in conferences where the servers have no need
  to access the contents (e.g. where audio is forwarded rather than
  mixed) than any other use of WebRTC audio by orders of magnitude.
  This is one of the primary use case for WebRTC audio and accounts
  for billions of minutes per month of potential use of WebRTC.
 </p>
 <p>
  In this use case, the JavaScript comes from the operator of the
  conference bridge. The isolated media features of WebRTC can
  prevent the JavaScript from accessing the media and the identity
  features are used to provide a user interface that allows the
  user to know it connected to the correct conference. The goal is
  for the end users to be able to see the contents, but the web
  service that provides the JS and the media switching bridges
  and Selective Forwarding Units (SFUs) cannot access the contents
  (audio, video, text). The browser may choose to reveal some
  metadata, such as the audio power level, to the media server,
  in order to support functions like speaker switching.
</p>
<p>
  A possible solution this problem is the browser to negotiate end to
  end encryption keys which are not revealed to the JavaScript.
</p>
  
<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   TBD
</pre>
          </section>
          <section id="trusted*">
<h4>Trusted Javascript</h4>

<p>In some highly controlled situations such as military uses,
  the JavaScript can come from a trusted source while the servers
  that distribute the packets are not trusted to access the
  contents in cleartext. The servers are trusted to forward
  packets as appropriate and not launch denial of service attacks
  on the conferences.
</p>
<p>
  In this case, the JavaScript running the WebRTC application comes
  from a trusted source and is allowed to access the contents in
  cleartext. These use cases tend to be relatively small deployments
  as they require the JavaScript come from a trusted source, but they
  use a media server from an untrusted source. The contents need to be
  encrypted with keys that are not known to the operator of the servers,
  servers, then sent to the conference server. The browser may choose
  to reveal some metadata, such as the audio power level, to the
  media server, in order to support functions like speaker switching.
</p>

<pre class="highlight">
   ----------------------------------------------------------------
   REQ-ID          DESCRIPTION
   ----------------------------------------------------------------
   TBD
</pre>
          </section>
    </section>
</section>
<section id="requirements*">
<h3>Requirements</h3>
<p>This section lists the requirements arising from
the use-cases catalogued in this document.</p>
<pre class="highlight">
  ----------------------------------------------------------------
   REQ-ID        DESCRIPTION
   ---------------------------------------------------------------
   N01           The user agent can control candidate gathering
                 and pruning, limiting the networks on which
                 candidates are gathered, the types of candidates,
                 etc.
   N02           The user agent must be capable of establishing multiple
                 connections to peers without generating a separate
                 configuration ("offer") for each connection prior to
                 establishment.
   N03           Congestion control must be able to manage audio
                 quality and latency in a fair manner between multiple
                 connections.
   N04           The ICE agent must be able to maintain multiple
                 candidate pairs and move traffic between them.
   N05           The ICE agent must be able to take the network
                 cost into account when considering re-routing.
   N06           The user agent must be able to encode and decode
                 video utilizing temporal scalability and (if
                 supported by the chosen codec) spatial scalability.
   N07           A user agent can receive audio/video without requiring
                 construction of a corresponding sender object.
   N08           It is possible to select the sending and/or
                 receiving codec without negotiation.
   N09           The user agent must be able to control
                 robustness (RTX, RED, FEC) applied to individual
                 simulcast and SVC layers.
   N10           It must be possible for the user agent to initiate
                 transfer of a large files with a single API operation.
   N11           The application must be able to signal backpressure
                 (flow control) when receiving data. It must also
                 receive a backpressure signal when sending data.
   N12           It must be possible for the user agent to transfer
                 data utilizing a congestion control algorithm
                 that does not compete aggressively with
                 audio/video communications.
   N13           It must be possible to support data exchange
                 in a worker.
   N14           The application must be able to minimize ICE
                 connectivity checks.
   N15           The application must be able to control aspects
                 of the data transport  (e.g. set the SCTP
                 heartbeat interval or turn it off), RTO values,
                 etc.
   N16           It must be possible to send arbitrary data
                 reliable, unreliable or partially reliable with
                 a specific maximum number of retransmissions
                 or a specific maximum timeout.
   N17           It must be possible to send arbitrary data
                 ordered or unordered.
   N18           The application must be able to obtain raw media
                 from the capture device in desired formats.
   N19           The application must be able to insert processed
                 frames into the outgoing media path.
   N20           The application must be able to obtain decoded
                 media from the remote party.
   N21           It must be possible to efficiently share media
                 between the main thread and worker threads.
   N22           It must be possible to do efficient media
                 manipulation in worker threads by utilizing the GPU.
   N23           The user agent must be able to send data synchronized
                 with audio.
</pre>
</section>

